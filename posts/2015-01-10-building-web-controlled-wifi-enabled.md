

<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-cp9r2kYQJa8/VKcfsWOY9tI/AAAAAAAAGbg/w7bYERlRInU/s1600/IMG_20141231_155202544.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="400" src="https://4.bp.blogspot.com/-cp9r2kYQJa8/VKcfsWOY9tI/AAAAAAAAGbg/w7bYERlRInU/s1600/IMG_20141231_155202544.jpg" width="225" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Testing the ESP8266 with an Arduino UNO.</td></tr></tbody></table>[<i>Update (May 1, 2016): The box itself has since seen a version upgrade, which <a href="http://blog.christopherkuzma.com/2016/05/wifi-enabled-power-plug-version-20.html">can be found here</a>.</i>]<br /><br />My <a href="http://blog.christopherkuzma.com/2015/01/arduino-controlled-christmas-lights.html" target="_blank">last project sought to create a light show</a> by using an Arduino board and a few relays to coordinate a light show. Fun stuff, but not really useful year-round. With the holiday season behind us, and having recently taken delivery of an ESP8266 WiFi module, I therefore decided to repurpose the parts to build something new. The thought was to combine my&nbsp;<a href="http://blog.christopherkuzma.com/2014/10/wittylights.html" target="_blank">#WittyLights project</a>&nbsp;with the new hardware to enable new methods of interaction.<br /><br />The first thing I had to do was figure out how to work with the WiFi module. It being relatively new to the market, there wasn't a lot of documentation available for it- at least, not much written in English. My initial attempts at getting the ESP to communicate with <a href="https://wit.ai/">Wit's API</a> were fruitless and, as a direct result of the lack of documentation, I quickly decided that there were simply too many potential reasons for why my efforts were not successful. I therefore decided to change focus and instead configure the Arduino to respond to incoming requests as opposed to initiating requests itself. A separate computer, cloud-based or local, would be responsible for all of the data processing and then forward along a simplified command to the Arduino over the internet or local network.<br /><a name='more'></a><br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-hcsl_VeZI1k/VLHGTJi7DbI/AAAAAAAAGcY/b_Va5LRdez4/s1600/Screen%2BShot%2B2015-01-10%2Bat%2B7.06.40%2BPM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="282" src="https://1.bp.blogspot.com/-hcsl_VeZI1k/VLHGTJi7DbI/AAAAAAAAGcY/b_Va5LRdez4/s1600/Screen%2BShot%2B2015-01-10%2Bat%2B7.06.40%2BPM.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Testing the ESP8266 using the Arduino's USB to UART bridge.</td></tr></tbody></table><br />After a bit of trial and error I eventually figured out which commands should be sent to the ESP in order to prep it for incoming requests, as well as how to handle said requests once they were passed to the Arduino. Once I managed to sort all of that out, it was a rather straightforward process to figure out how to return some sort of a command-received-successfully message back to whoever made the original request. This I eventually decided to format as a JSON object and return the current command being performed by the board.<br /><br /><div style="text-align: center;"><a href="http://goo.gl/SsE4YQ"><span style="font-size: large;"><b>Click here to access the sketch on GitHub</b></span></a></div><br />This sketch allows you to control pins 2-10 by making a simple HTTP request from another device, such as the browser on a computer. It then returns a message which can be used to determine whether or not the sent command was properly executed. My own setup involves the same 4-channel relay board and 2-plug receptacles that were employed in my previous project, allowing for complete control of the circuits' power states from anywhere in the world. Now I have an easy means of communicating with the board, facilitating implementation into a Twitterbot, website, mobile application or even something else entirely. Cool, huh?<br /><br />